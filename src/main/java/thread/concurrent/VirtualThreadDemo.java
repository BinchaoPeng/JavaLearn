package thread.concurrent;

/**
 * Java 19 引入的，适用于【IO密集型任务】，默认不启用
 * 虚拟线程不是由操作系统调度，而是由普通线程调度，即成百上千个虚拟线程可以由一个普通线程调度。
 * 任何时刻，只能执行一个虚拟线程，但是，一旦该虚拟线程执行一个IO操作进入等待时，它会被立刻“挂起”，然后执行下一个虚拟线程。
 * 什么时候IO数据返回了，这个挂起的虚拟线程才会被再次调度。
 *
 * Java 19引入的虚拟线程是为了解决IO密集型任务的吞吐量，它可以高效通过少数线程去调度大量虚拟线程；
 * 虚拟线程在执行到IO操作或Blocking操作时，会自动切换到其他虚拟线程执行，从而避免当前线程等待，能最大化线程的执行效率；
 * 虚拟线程使用普通线程相同的接口，最大的好处是无需修改任何代码，就可以将现有的IO操作异步化获得更大的吞吐能力。
 * 计算密集型任务不应使用虚拟线程，只能通过增加CPU核心解决，或者利用分布式计算资源。
 */
public class VirtualThreadDemo {
    public static void main(String[] args) {

    }
}
